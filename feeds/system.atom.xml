<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jack's Blog</title><link href="/" rel="alternate"></link><link href="/feeds/system.atom.xml" rel="self"></link><id>/</id><updated>2014-07-28T20:20:00+08:00</updated><entry><title>Linux内核策略介绍学习笔记</title><link href="/linux-kernel-introduce.html" rel="alternate"></link><updated>2014-07-28T20:20:00+08:00</updated><author><name>jacksu</name></author><id>tag:,2014-07-28:linux-kernel-introduce.html</id><summary type="html">&lt;h1&gt;主要内容&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;硬件&lt;/th&gt;
&lt;th&gt;策略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;进程调度、系统调用、中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;内存管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外存&lt;/td&gt;
&lt;td&gt;文件IO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络&lt;/td&gt;
&lt;td&gt;协议栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他&lt;/td&gt;
&lt;td&gt;时间管理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img alt="linux kernel map" src="http://p.blog.csdn.net/images/p_blog_csdn_net/gausing/EntryImages/20090609/linux内核代码架构图-清晰版.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;进程调度&lt;/h2&gt;
&lt;h3&gt;内核的运行时间&lt;/h3&gt;
&lt;p&gt;系统启动、中断发生、系统调用以及&lt;strong&gt;内核线程&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;进程和线程的区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在linux中，底层都是调用clone函数。&lt;/li&gt;
&lt;li&gt;进程创建为60～8000次/s，线程为5～10w/s&lt;/li&gt;
&lt;li&gt;进程创建调用fork()，主要瓶颈在页表复制，如果一个进程没有访问内存，页表共享的内存栈不需要复制页表。（例如：一个网络处理服务，只是收到包，fork进程进行内存访问，性能应该在一万左右，但是如果主进程简单做一些处理的话，性能就会下降为一千左右。）&lt;/li&gt;
&lt;li&gt;线程创建调用pthread_create(),主要瓶颈在堆栈(8k)分配上，如果并发线程增多1w时约为5w&lt;/li&gt;
&lt;li&gt;并发性能CPU切换，进程30～100w/s,线程50～150w/s&lt;/li&gt;
&lt;li&gt;内存消耗，进程要比线程更消耗内存(3~N倍)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;进程调度&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;sched_yield更细粒度让出cpu&lt;/li&gt;
&lt;li&gt;各个核都有自己的运行队列&lt;/li&gt;
&lt;li&gt;就近balance原则，运行clone、wakeup的进程就在该核&lt;/li&gt;
&lt;li&gt;CPU绑定函数sched_setaffinity&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;中断&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通过/proc/interrupt查看中断&lt;/li&gt;
&lt;li&gt;中断主要来源于时钟、网卡、硬盘&lt;/li&gt;
&lt;li&gt;通过/proc/irq/N/smp_affinity查看在那个核&lt;/li&gt;
&lt;li&gt;调度顺序：硬中断调度－&amp;gt;软中断－&amp;gt;进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;常用系统调用性能&lt;/h2&gt;
&lt;p&gt;是在C类机器测试，自己使用最好在自己的机器类型测试。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;&lt;/th&gt;
&lt;th align="center"&gt;性能（次/秒）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;ntohl&lt;/td&gt;
&lt;td align="center"&gt;2.5亿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;memset 1k&lt;/td&gt;
&lt;td align="center"&gt;150w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;getppid&lt;/td&gt;
&lt;td align="center"&gt;100w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;gettimeofday&lt;/td&gt;
&lt;td align="center"&gt;30~400w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;time&lt;/td&gt;
&lt;td align="center"&gt;30w~400w~1000w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;shmget&lt;/td&gt;
&lt;td align="center"&gt;300w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;shmat&lt;/td&gt;
&lt;td align="center"&gt;40w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;socket&lt;/td&gt;
&lt;td align="center"&gt;10w~50w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;sendto&lt;/td&gt;
&lt;td align="center"&gt;40w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;fork&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;pthread_create&lt;/td&gt;
&lt;td align="center"&gt;5~10w&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;工具&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;stack&lt;/li&gt;
&lt;li&gt;perf&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;内存管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看进程地址空间/proc/PID/maps或者pmap&lt;/li&gt;
&lt;li&gt;防止内存交换出去调用mlock，如果内存使用非常紧张的时候得注意&lt;/li&gt;
&lt;li&gt;空闲内存计算：/proc/meminfo查看，MemFree+cached+buffer-Mapped&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;共享内存建立方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IPC 我们经常使用&lt;/li&gt;
&lt;li&gt;shm_open，文件操作，方便append和dump&lt;/li&gt;
&lt;li&gt;tmpfs可以直接挂载到某个盘&lt;/li&gt;
&lt;li&gt;hugetlbfs节省页表空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;内存权限&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;&lt;/th&gt;
&lt;th align="center"&gt;shared&lt;/th&gt;
&lt;th align="center"&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;File&lt;/td&gt;
&lt;td align="center"&gt;共享内存&lt;/td&gt;
&lt;td align="center"&gt;数据段、代码段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;anon&lt;/td&gt;
&lt;td align="center"&gt;父子进程&lt;/td&gt;
&lt;td align="center"&gt;堆&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;文件IO&lt;/h2&gt;
&lt;p&gt;文件系统层次架构&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;VFS Layer&lt;/li&gt;
&lt;li&gt;NFS EXT2 EXT3 NTFS&lt;/li&gt;
&lt;li&gt;Page Cache&lt;/li&gt;
&lt;li&gt;Generic Block Layer&lt;/li&gt;
&lt;li&gt;I/O Scheduler Layer&lt;/li&gt;
&lt;li&gt;Block Device Driver Layer&lt;/li&gt;
&lt;li&gt;Block Device Layer&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;PageCache起了缓存得作用，采用read ahead机制，如果我们顺序读性能比较好，随机读性能就比较差了。对于写，如果在pagecache中存在，那么直接写PacheCache中的页就可以，否则需要加载该页内容，然后写入PageCache，最后delay write。&lt;/p&gt;
&lt;p&gt;虚拟文件系统为filetab[fd]-&amp;gt;file-&amp;gt;dentry-&amp;gt;inode-&amp;gt;mapping.dentry采用全局hash，查找性能为30～35w/s,100w个文件也为30w/s。&lt;/p&gt;
&lt;p&gt;EXT3添加了日志模式，由高到低为journal、ordered、writeback&lt;/p&gt;
&lt;h2&gt;协议栈&lt;/h2&gt;
&lt;p&gt;&lt;img alt="prototcol_stack" src="../../static/system/protocol_stack" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;recv_queue中的包大小，为内核的包大小，而不是ip包大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果发出去的包太大，需要修改write_queue和tx_queue两个参数，tx_queue主要是流量控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;多进程必须在socket后再fork，即使设置了REUSEADDR，从hashtable看出原因。&lt;/li&gt;
&lt;li&gt;net.ipv4.tcp_max_syn_backlog参数决定了SYN_RECV状态队列的数量，一般默认值为512或者1024，即超过这个数量，系统将不再接受新的TCP连接请求.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/justlinux2010/article/details/12619761"&gt;sync cookie&lt;/a&gt;,外网要注意，同一个集线器来的用户，可能导致大量不可以建立链接。&lt;/li&gt;
&lt;li&gt;somaxconn决定了listen监听队列的大小&lt;/li&gt;
&lt;li&gt;select有1024的限制，即使没有达到1024，但是分配的fd大于1024也会有问题。&lt;/li&gt;
&lt;li&gt;epoll多用于单进程多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;时间&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gettimeofday根据硬件不同性能差距很大&lt;/li&gt;
&lt;li&gt;usleep(1),睡眠不一定是1微妙，有可能是毫秒级的，也和硬件有关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;man 2&lt;/p&gt;
&lt;p&gt;man 7&lt;/p&gt;
&lt;p&gt;ULK&lt;/p&gt;</summary><category term="linux"></category></entry></feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jack's Blog</title><link href="/" rel="alternate"></link><link href="/feeds/jacksu.atom.xml" rel="self"></link><id>/</id><updated>2014-08-19T00:20:00+08:00</updated><entry><title>C++并行编程1</title><link href="/c-concurrency-in-action-1.html" rel="alternate"></link><updated>2014-08-19T00:20:00+08:00</updated><author><name>jacksu</name></author><id>tag:,2014-08-19:c-concurrency-in-action-1.html</id><summary type="html">&lt;h2&gt;what is concurrency&lt;/h2&gt;
&lt;p&gt;我们可以一边看电视，一边唱歌。人并行非常容易理解，但是计算机呢？是不是我们一边编辑着word文档，一边听着歌，这样计算机就是在并行吗？不一定欧，如果你计算机是单核，就一定不是并行了，而是把你的任务分成你根本感觉不到的任务片，近似在并行执行，其实是在串行执行。如果是双核，也不一定，有可能一个核上同时执行两个任务，也有可能是并行欧，不同核执行不同的任务。&lt;/p&gt;
&lt;p&gt;并行执行有两种实现方法：
多进程：启动比较复杂并且比较慢，操作系统需要额外的资源来管理进程，但是容易写比线程安全的代码。&lt;/p&gt;
&lt;p&gt;多线程：线程之间更容易通信，启动和通信也比进程开销小。&lt;/p&gt;
&lt;h2&gt;why use concurrency&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;拆分任务&lt;/li&gt;
&lt;li&gt;合理利用性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常有三种并行的方法：&lt;/p&gt;
&lt;h3&gt;task parallelism&lt;/h3&gt;
&lt;p&gt;把一个任务拆分成不同部分，并行执行&lt;/p&gt;
&lt;h3&gt;data parallelism&lt;/h3&gt;
&lt;p&gt;把数据分成不同部分，线程在不同数据上执行相同操作。&lt;/p&gt;
&lt;h3&gt;embarrassingly parallel&lt;/h3&gt;
&lt;p&gt;算法变为并行执行算法&lt;/p&gt;
&lt;h2&gt;why not use concurrency&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;执行任务容易完成，但是线程启动也需要开销&lt;/li&gt;
&lt;li&gt;启动线程太多，容易消耗完内存和地址空间（特别是32位机器），容易消耗完系统资源，比如每个链接建立一个线程，还有切换开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;hello world&lt;/h2&gt;
&lt;p&gt;需要在C++11环境下编译。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;thread&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;thread&lt;/span&gt; &lt;span class="nb"&gt;t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;t.join&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="C++"></category></entry><entry><title>分布式系统－terms</title><link href="/distribute-system-terms.html" rel="alternate"></link><updated>2014-08-13T11:20:00+08:00</updated><author><name>jacksu</name></author><id>tag:,2014-08-13:distribute-system-terms.html</id><summary type="html">&lt;p&gt;Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers.&lt;/p&gt;
&lt;h2&gt;Scalability&lt;/h2&gt;
&lt;p&gt;处理每件事情都需要注意它的规模，如果规模达到一定程度，处理的难度明显加强。例如你可以计算出一个房间中的人数，但是很难计算出一个国家的人数。在一个可扩展的分布式系统中，系统从小变大，但是相关性能没有变差。&lt;/p&gt;
&lt;p&gt;比如在单机文件系统上加 RAID5 做数据冗余，来解决单机文件系统的可靠性问题。假设 RAID5 的数据修复时间是1天（实际上往往做不到，尤其是业务系统本身压力比较大的情况下，留给 RAID 修复用的磁盘读写带宽很有限），这种方案单机的可靠性大概是100年丢失一次数据（即可靠性是2个9）。看起来尚可？但是你得小心两种情况。一种是你的集群规模变大，你仍然沿用这个土方法，比如你现在有 100 台这样的机器，那么就会变成1年就丢失一次数据。另一种情况是如果实际数据修复时间是 3 天，那么单机的可靠性就直降至4年丢失一次数据，100台就会是15天丢失一次数据。这个数字显然无法让人接受。&lt;/p&gt;
&lt;p&gt;scalability（可扩展性）是指在一个系统、网络以及处理能力范围内，可以处理不断增长的任务，并它们可以加强自己的能力来适应任务的增长（有点儿抽象）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大小可扩展性：增加节点可以线性增加性能，并数据集的增加不增加延迟性&lt;/li&gt;
&lt;li&gt;地理位置可扩展性：数据中心间延迟性采用合理的方式处理，则可以跨数据中心，减少用户数据查询响应时间&lt;/li&gt;
&lt;li&gt;管理可扩展性：增加更多的节点不增加管理的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;性能特点是在一定任务情况下，系统处理所需要的时间和资源使用量来衡量的。如快速回复（低延迟性）、高吞吐量以及计算资源低使用率。但是这几个性能，在实际中只能权衡。&lt;/p&gt;
&lt;h2&gt;latency&lt;/h2&gt;
&lt;p&gt;延迟性指事件初始化和发生的时间段。比如在分布式系统中写操作，就写发生到新的数据可以被用户看到的时间段。latency经常要受一些硬件（ram的性能、cpu性能）的限制。&lt;/p&gt;
&lt;h2&gt;Availability&lt;/h2&gt;
&lt;p&gt;指系统处在运行状态时间的比例，用户不可以访问，那么系统就是不可用。
分布式系统上可以获得单机非常的特性，比如单机就是无法容忍机器宕机。分布式系统可以由一些非常不好的组件构成，但是可以提供可信赖的系统。 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Availability = uptime / (uptime + downtime)&lt;/code&gt;   &lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Availability %&lt;/th&gt;
&lt;th&gt;How much downtime is allowed per year?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;90% ("one nine")&lt;/td&gt;
&lt;td&gt;More than a month&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99% ("two nines")&lt;/td&gt;
&lt;td&gt;Less than 4 days&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.9% ("three nines")&lt;/td&gt;
&lt;td&gt;Less than 9 hours&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.99% ("four nines")&lt;/td&gt;
&lt;td&gt;Less than an hour&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.999% ("five nines")&lt;/td&gt;
&lt;td&gt;~ 5 minutes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.9999% ("six nines")&lt;/td&gt;
&lt;td&gt;~ 31 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;availability不仅仅是uptime，还可能受网络中断以及该业务超出系统的功能的影响。&lt;/p&gt;
&lt;h2&gt;Fault tolerance&lt;/h2&gt;
&lt;p&gt;指在故障发生时，系统还可以正常运行（和没有发生故障时功能相同）的能力。&lt;/p&gt;
&lt;p&gt;容错归结为：确定你所期望的故障，然后设计一个系统或一个算法可以容错他们。没有考虑过故障是无法容错的。&lt;/p&gt;
&lt;h2&gt;什么在阻止我们获得理想的状态呢？&lt;/h2&gt;
&lt;p&gt;有以下两个硬件方面的因素：&lt;/p&gt;
&lt;p&gt;1 nodes的数量&lt;/p&gt;
&lt;p&gt;2 nodes的距离&lt;/p&gt;
&lt;p&gt;伴随着以下限制：&lt;/p&gt;
&lt;p&gt;1 独立节点的增加，就增加了系统失败的概率（减小了availability并增加了管理成本）&lt;/p&gt;
&lt;p&gt;2 独立节点的增加，就增加了节点的通信 （降低了可扩展的performance）&lt;/p&gt;
&lt;p&gt;3 节点的跨机房部署，增加了节点之间的延迟性（降低了某些操作的performance）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可用性和性能&lt;/strong&gt;是系统必须保证的，更高一级，可以考虑SLA（服务等级协议），如果我写数据，如何更快在其他地方看到？&lt;/p&gt;
&lt;p&gt;在数据被写入时，什么可以保证耐久性？如果让系统运行一个计算，如何迅速返回结果？当组件发生故障，执行取出操作，什么样的影响将在在系统上？&lt;/p&gt;
&lt;h2&gt;设计技术：partition and replicate&lt;/h2&gt;
&lt;p&gt;如果要把数据分布在不同节点，那么上面两个技术非常关键。数据可以被分割在多个节点（partition），以允许更多的并行处理。也可以被复制或缓存在不同的节点上，以减少客户端和服务器之间距离以及更大的容错性（replicate）
&lt;img alt="partition" src="http://book.mixu.net/distsys/images/part-repl.png" /&gt;&lt;/p&gt;
&lt;p&gt;partitioning是把数据分成相互独立的数据集，这样可以避免数据的增长带来的影响。partitioning是通过限制被检查数据集的大小和定位相关数据在相同partition来提高性能的（如一个数据一分钟的记录，那么这个数据分布在一台机器和多台机器性能是截然不同的）。容许partition独立失败，来挺高可用性。在不可用情况下，容易更多节点失败。&lt;/p&gt;
&lt;p&gt;replication可以通过复制数据集，提高计算和带宽能力。可以提高可用性，在不可用情况下，容易更多节点失败。当然replication又会带来一致性问题，后面再讨论一致性的问题。&lt;/p&gt;
&lt;h2&gt;参考文献：&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.morganclaypool.com/doi/pdf/10.2200/s00193ed1v01y200905cac006"&gt;The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - Barroso &amp;amp; Hölzle, 2008&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing"&gt;Fallacies of Distributed Computing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/"&gt;Notes on Distributed Systems for Young Bloods - Hodges, 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://book.mixu.net/distsys/intro.html"&gt;Distributed systems at a high level&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary><category term="distribute system"></category></entry><entry><title>Linux内核策略介绍学习笔记</title><link href="/linux-kernel-introduce.html" rel="alternate"></link><updated>2014-07-28T20:20:00+08:00</updated><author><name>jacksu</name></author><id>tag:,2014-07-28:linux-kernel-introduce.html</id><summary type="html">&lt;h1&gt;主要内容&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;硬件&lt;/th&gt;
&lt;th&gt;策略&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;进程调度、系统调用、中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;内存管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;外存&lt;/td&gt;
&lt;td&gt;文件IO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络&lt;/td&gt;
&lt;td&gt;协议栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他&lt;/td&gt;
&lt;td&gt;时间管理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img alt="linux kernel map" src="http://p.blog.csdn.net/images/p_blog_csdn_net/gausing/EntryImages/20090609/linux内核代码架构图-清晰版.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;进程调度&lt;/h2&gt;
&lt;h3&gt;内核的运行时间&lt;/h3&gt;
&lt;p&gt;系统启动、中断发生、系统调用以及&lt;strong&gt;内核线程&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;进程和线程的区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在linux中，底层都是调用clone函数。&lt;/li&gt;
&lt;li&gt;进程创建为60～8000次/s，线程为5～10w/s&lt;/li&gt;
&lt;li&gt;进程创建调用fork()，主要瓶颈在页表复制，如果一个进程没有访问内存，页表共享的内存栈不需要复制页表。（例如：一个网络处理服务，只是收到包，fork进程进行内存访问，性能应该在一万左右，但是如果主进程简单做一些处理的话，性能就会下降为一千左右。）&lt;/li&gt;
&lt;li&gt;线程创建调用pthread_create(),主要瓶颈在堆栈(8k)分配上，如果并发线程增多1w时约为5w&lt;/li&gt;
&lt;li&gt;并发性能CPU切换，进程30～100w/s,线程50～150w/s&lt;/li&gt;
&lt;li&gt;内存消耗，进程要比线程更消耗内存(3~N倍)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;进程调度&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;sched_yield更细粒度让出cpu&lt;/li&gt;
&lt;li&gt;各个核都有自己的运行队列&lt;/li&gt;
&lt;li&gt;就近balance原则，运行clone、wakeup的进程就在该核&lt;/li&gt;
&lt;li&gt;CPU绑定函数sched_setaffinity&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;中断&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通过/proc/interrupt查看中断&lt;/li&gt;
&lt;li&gt;中断主要来源于时钟、网卡、硬盘&lt;/li&gt;
&lt;li&gt;通过/proc/irq/N/smp_affinity查看在那个核&lt;/li&gt;
&lt;li&gt;调度顺序：硬中断调度－&amp;gt;软中断－&amp;gt;进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;常用系统调用性能&lt;/h2&gt;
&lt;p&gt;是在C类机器测试，自己使用最好在自己的机器类型测试。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;&lt;/th&gt;
&lt;th align="center"&gt;性能（次/秒）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;ntohl&lt;/td&gt;
&lt;td align="center"&gt;2.5亿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;memset 1k&lt;/td&gt;
&lt;td align="center"&gt;150w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;getppid&lt;/td&gt;
&lt;td align="center"&gt;100w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;gettimeofday&lt;/td&gt;
&lt;td align="center"&gt;30~400w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;time&lt;/td&gt;
&lt;td align="center"&gt;30w~400w~1000w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;shmget&lt;/td&gt;
&lt;td align="center"&gt;300w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;shmat&lt;/td&gt;
&lt;td align="center"&gt;40w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;socket&lt;/td&gt;
&lt;td align="center"&gt;10w~50w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;sendto&lt;/td&gt;
&lt;td align="center"&gt;40w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;fork&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;pthread_create&lt;/td&gt;
&lt;td align="center"&gt;5~10w&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;工具&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;stack&lt;/li&gt;
&lt;li&gt;perf&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;内存管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查看进程地址空间/proc/PID/maps或者pmap&lt;/li&gt;
&lt;li&gt;防止内存交换出去调用mlock，如果内存使用非常紧张的时候得注意&lt;/li&gt;
&lt;li&gt;空闲内存计算：/proc/meminfo查看，MemFree+cached+buffer-Mapped&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;共享内存建立方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IPC 我们经常使用&lt;/li&gt;
&lt;li&gt;shm_open，文件操作，方便append和dump&lt;/li&gt;
&lt;li&gt;tmpfs可以直接挂载到某个盘&lt;/li&gt;
&lt;li&gt;hugetlbfs节省页表空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;内存权限&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;&lt;/th&gt;
&lt;th align="center"&gt;shared&lt;/th&gt;
&lt;th align="center"&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;File&lt;/td&gt;
&lt;td align="center"&gt;共享内存&lt;/td&gt;
&lt;td align="center"&gt;数据段、代码段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;anon&lt;/td&gt;
&lt;td align="center"&gt;父子进程&lt;/td&gt;
&lt;td align="center"&gt;堆&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;文件IO&lt;/h2&gt;
&lt;p&gt;文件系统层次架构&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;VFS Layer&lt;/li&gt;
&lt;li&gt;NFS EXT2 EXT3 NTFS&lt;/li&gt;
&lt;li&gt;Page Cache&lt;/li&gt;
&lt;li&gt;Generic Block Layer&lt;/li&gt;
&lt;li&gt;I/O Scheduler Layer&lt;/li&gt;
&lt;li&gt;Block Device Driver Layer&lt;/li&gt;
&lt;li&gt;Block Device Layer&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;PageCache起了缓存得作用，采用read ahead机制，如果我们顺序读性能比较好，随机读性能就比较差了。对于写，如果在pagecache中存在，那么直接写PacheCache中的页就可以，否则需要加载该页内容，然后写入PageCache，最后delay write。&lt;/p&gt;
&lt;p&gt;虚拟文件系统为filetab[fd]-&amp;gt;file-&amp;gt;dentry-&amp;gt;inode-&amp;gt;mapping.dentry采用全局hash，查找性能为30～35w/s,100w个文件也为30w/s。&lt;/p&gt;
&lt;p&gt;EXT3添加了日志模式，由高到低为journal、ordered、writeback&lt;/p&gt;
&lt;h2&gt;协议栈&lt;/h2&gt;
&lt;p&gt;&lt;img alt="prototcol_stack" src="../../static/system/protocol_stack" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;recv_queue中的包大小，为内核的包大小，而不是ip包大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果发出去的包太大，需要修改write_queue和tx_queue两个参数，tx_queue主要是流量控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;多进程必须在socket后再fork，即使设置了REUSEADDR，从hashtable看出原因。&lt;/li&gt;
&lt;li&gt;net.ipv4.tcp_max_syn_backlog参数决定了SYN_RECV状态队列的数量，一般默认值为512或者1024，即超过这个数量，系统将不再接受新的TCP连接请求.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/justlinux2010/article/details/12619761"&gt;sync cookie&lt;/a&gt;,外网要注意，同一个集线器来的用户，可能导致大量不可以建立链接。&lt;/li&gt;
&lt;li&gt;somaxconn决定了listen监听队列的大小&lt;/li&gt;
&lt;li&gt;select有1024的限制，即使没有达到1024，但是分配的fd大于1024也会有问题。&lt;/li&gt;
&lt;li&gt;epoll多用于单进程多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;时间&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gettimeofday根据硬件不同性能差距很大&lt;/li&gt;
&lt;li&gt;usleep(1),睡眠不一定是1微妙，有可能是毫秒级的，也和硬件有关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;man 2&lt;/p&gt;
&lt;p&gt;man 7&lt;/p&gt;
&lt;p&gt;ULK&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>个人github blog环境设置</title><link href="/my-github-blog-set.html" rel="alternate"></link><updated>2014-07-27T00:20:00+08:00</updated><author><name>jacksu</name></author><id>tag:,2014-07-27:my-github-blog-set.html</id><summary type="html">&lt;h1&gt;软件安装&lt;/h1&gt;
&lt;p&gt;大体需要以下几个东东，个性化的就需要自己去搜寻。&lt;/p&gt;
&lt;h2&gt;pelican&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;我们需要网站的管理工具pelican，pelican可以把markdown的文件生成html和pdf，pelican又依赖于pipe，安装命令如下：&lt;br&gt;
&lt;code&gt;sudo easy_install pipe&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sudo pip install pelican&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;检查是否安装成功&lt;/h3&gt;
&lt;p&gt;执行如下命令：&lt;br&gt;
&lt;code&gt;pelican -h&lt;/code&gt;或者
&lt;code&gt;pelican .md所在目录&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Markdown包&lt;/h2&gt;
&lt;p&gt;pelican不可以识别markdown，需要下载markdown包，markdown的下载方式为：&lt;br&gt;
&lt;code&gt;sudo pip install Markdown&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;主题&lt;/h2&gt;
&lt;p&gt;没有主题，你的网站太难看了，那么下载一个主题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/farseerfc/pelican-themes&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;设置&lt;/h1&gt;
&lt;h2&gt;github上的设置&lt;/h2&gt;
&lt;p&gt;在github上建立&lt;strong&gt;&lt;code&gt;username.github.io&lt;/code&gt;&lt;/strong&gt;的项目（如何在github建立项目，我就不说了，应该很多人会），参考&lt;a href="https://help.github.com/articles/creating-pages-with-the-automatic-generator"&gt;官方文档&lt;/a&gt;设置，过&lt;strong&gt;十分钟&lt;/strong&gt;左右你就可以通过&lt;code&gt;username.github.io&lt;/code&gt;访问了。&lt;/p&gt;
&lt;h2&gt;settings.py设置&lt;/h2&gt;
&lt;p&gt;settings.py的内容大体如下，我也是参考&lt;a href="http://x-wei.github.io/pelican_github_blog.html"&gt;mx的blog&lt;/a&gt;的.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="o"&gt;-*-&lt;/span&gt; &lt;span class="nx"&gt;coding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;-*-&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nx"&gt;sys&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;zhs&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;X. Wei&amp;#39;s Blog&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;X.Wei&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;xweisblog&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;https://github.com/X-Wei&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="vi"&gt;#github&lt;/span&gt;&lt;span class="err"&gt;链接&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;http://x-wei.github.com&amp;gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;UA-30756331-1&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;#谷歌站点分析&lt;/span&gt;
&lt;span class="n"&gt;TAG_FEED&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;feeds/%s.atom.xml&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;#默认每一页有多少篇文章&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;misc&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;#需要把输出路径从默认的&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;改成根目录&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;your_id.github.com&lt;/span&gt;&lt;span class="err"&gt;目录&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="err"&gt;因为&lt;/span&gt;&lt;span class="nx"&gt;githubpage&lt;/span&gt;&lt;span class="err"&gt;需要把&lt;/span&gt;&lt;span class="nx"&gt;index.html&lt;/span&gt;&lt;span class="err"&gt;上传到&lt;/span&gt;&lt;span class="nx"&gt;repo&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="nx"&gt;master&lt;/span&gt;&lt;span class="err"&gt;分支的根目录才可以&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;posts&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;#这个是指定放置&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;md&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;.rst&lt;/span&gt;&lt;span class="err"&gt;文件的目录&lt;/span&gt;

&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;dofine&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;http://www.dofine.me&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;farseerfc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;http://farseerfc.github.com/&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;#友情链接~&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;https://github.com/x-wei&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;#社交网络链接&lt;/span&gt;
          &lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;twitter&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;http://twitter.com/farseerfc&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;facebook&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;http://www.facebook.com/farseerfc&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;weibo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;http://weibo.com/farseerfc&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;renren&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;http://www.renren.com/farseer&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;

&lt;span class="err"&gt;#这个是&lt;/span&gt;&lt;span class="nx"&gt;farseerfc&lt;/span&gt;&lt;span class="err"&gt;同学自己加的&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;可以显示他的新浪微博内容&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;有微博的话可以把这些加上~&lt;/span&gt;
&lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="n"&gt;TWITTER_USERNAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;farseerfc&amp;#39;&lt;/span&gt;
&lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="n"&gt;SIDEBAR_CUSTOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;#~ &amp;lt;li class=&amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;nav&lt;/span&gt;&lt;span class="na"&gt;-header&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;lt;h4&amp;gt;&amp;lt;i class=&amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;icon&lt;/span&gt;&lt;span class="na"&gt;-list-alt&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;Weibo&amp;lt;/h4&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;#~ &amp;lt;iframe width=&amp;quot;&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; height=&amp;quot;&lt;/span&gt;&lt;span class="mi"&gt;550&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; class=&amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;share_self&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;  frameborder=&amp;quot;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; scrolling=&amp;quot;&lt;/span&gt;&lt;span class="nx"&gt;no&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; &lt;/span&gt;
&lt;span class="s2"&gt;#~ src=&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//widget.weibo.com/weiboshow/index.php?language=&amp;amp;width=0&amp;amp;height=550&amp;amp;fansRow=1&amp;amp;ptype=1&amp;amp;speed=0&amp;amp;skin=2&amp;amp;isTitle=1&amp;amp;noborder=1&amp;amp;isWeibo=1&amp;amp;isFans=1&amp;amp;uid=1862842353&amp;amp;verifier=b193b9de&amp;amp;dpc=1&amp;gt;&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nx"&gt;iframe&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;#~&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="s2"&gt;#google自定义搜索(大概是站内搜索吧)&lt;/span&gt;
&lt;span class="s2"&gt;#~ GOOGLE_CUSTOM_SEARCH_SIDEBAR = &amp;quot;&lt;/span&gt;&lt;span class="mi"&gt;001578481551708017171&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;axpo6yvtdyg&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;#~ GOOGLE_CUSTOM_SEARCH_NAVBAR = &amp;quot;&lt;/span&gt;&lt;span class="mi"&gt;001578481551708017171&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;hxkva69brmg&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我的&lt;a href="https://github.com/jacksu/jacksu.github.io/blob/master/settings.py"&gt;settings.py&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;md头&lt;/h2&gt;
&lt;p&gt;每个md文件必须包含下面相关内容，各个字段含义应该通过英文意思就可以看出来。&lt;/p&gt;
&lt;p&gt;Title: 个人github blog环境设置&lt;/p&gt;
&lt;p&gt;Date: 2014-7-27 00:20&lt;/p&gt;
&lt;p&gt;Modified: 2014-7-27 00:20&lt;/p&gt;
&lt;p&gt;Category: env_set&lt;/p&gt;
&lt;p&gt;Tags: github&lt;/p&gt;
&lt;p&gt;Slug: my-github-blog-set&lt;/p&gt;
&lt;p&gt;Author: jacksu&lt;/p&gt;
&lt;p&gt;Summary: 每个人都想拥有自己的网站，但是大部分比较屌丝，不想花钱租赁服务器，哈哈，屌丝有屌丝办法。github应该都听说过吧，github.io提供了此功能，而且使用github来管理自己的代码，如果你有域名，还可以绑定你自己的域名欧。我在github的博客终于捣鼓好了，也给大家介绍一下建站步骤。&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;建站&lt;/h1&gt;
&lt;p&gt;把刚才github的项目拉到本地，执行如下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/username/username.github.io&lt;/code&gt;&lt;br&gt;
&lt;code&gt;pelican -s settings.py -t ../pelican-themes/bootstrap2/ posts/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中－t后面是你的主题目录，posts是md所在的目录。再执行如下命令:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit -m "add"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们的个人网站建成了，可以访问&lt;code&gt;usrname.github.io&lt;/code&gt;了.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="htttp://jacksu.github.io"&gt;jacksu blog&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</summary><category term="github"></category></entry></feed>